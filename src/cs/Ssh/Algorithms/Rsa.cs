// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Security.Cryptography;
using System.Text;
using Microsoft.DevTunnels.Ssh.IO;

namespace Microsoft.DevTunnels.Ssh.Algorithms;

public class Rsa : PublicKeyAlgorithm
{
	public new const string KeyAlgorithmName = "ssh-rsa";

	public const string RsaWithSha256 = "rsa-sha2-256";
	public const string RsaWithSha512 = "rsa-sha2-512";

	public Rsa(string name, string hashAlgorithmName)
		: base(name, KeyAlgorithmName, hashAlgorithmName)
	{
	}

	public override IKeyPair CreateKeyPair()
	{
		return new KeyPair();
	}

	public override IKeyPair GenerateKeyPair(int? keySizeInBits = null)
	{
		return new KeyPair(keySizeInBits);
	}

	public override ISigner CreateSigner(IKeyPair keyPair)
	{
		var rsaKeyPair = keyPair as KeyPair;
		if (rsaKeyPair == null) throw new ArgumentException("RSA key pair object expected.");

		return new SignerVerifier(rsaKeyPair, ConvertHashAlgorithmName(HashAlgorithmName));
	}

	public override IVerifier CreateVerifier(IKeyPair keyPair)
	{
		var rsaKeyPair = keyPair as KeyPair;
		if (rsaKeyPair == null) throw new ArgumentException("RSA key pair object expected.");

		return new SignerVerifier(rsaKeyPair, ConvertHashAlgorithmName(HashAlgorithmName));
	}

	private static HashAlgorithmName ConvertHashAlgorithmName(string hashAlgorithmName)
	{
		return hashAlgorithmName switch
		{
			HmacAlgorithm.Sha256 => System.Security.Cryptography.HashAlgorithmName.SHA256,
			HmacAlgorithm.Sha512 => System.Security.Cryptography.HashAlgorithmName.SHA512,
			_ => throw new ArgumentException(
				"Invalid or unsupported RSA hash algorithm: " + hashAlgorithmName,
				nameof(hashAlgorithmName)),
		};
	}

#pragma warning disable CA1034 // Nested types should not be visible
	public class KeyPair : IKeyPair
#pragma warning restore CA1034 // Nested types should not be visible
	{
		private const int DefaultKeySize = 2048;

		/// <summary>
		/// Creates a new public-private RSA key pair.
		/// </summary>
		/// <remarks>
		/// The key pair is not immediately generated by this constructor; it is actually generated
		/// by .NET on first-use. So if an existing key is imported before then, no new key will be
		/// generated.
		/// </remarks>
		public KeyPair(int? keySizeInBits = null)
#if NETSTANDARD2_0
				: this(new RSACryptoServiceProvider(keySizeInBits ?? DefaultKeySize))
#else
				: this(RSA.Create(keySizeInBits ?? DefaultKeySize))
#endif
		{
		}

		private KeyPair(RSA algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException(nameof(algorithm));
			}

			Algorithm = algorithm;
			HasPrivateKey = true;
		}

		public string KeyAlgorithmName => Rsa.KeyAlgorithmName;

		public bool HasPrivateKey { get; private set; }

		public string? Comment { get; set; }

		internal RSA Algorithm { get; }

		public void SetPublicKeyBytes(Buffer keyBytes)
		{
			var reader = new SshDataReader(keyBytes);

			string algorithmName = reader.ReadString(Encoding.ASCII);
			if (algorithmName != KeyAlgorithmName &&
				algorithmName != Rsa.RsaWithSha256 &&
				algorithmName != Rsa.RsaWithSha512)
			{
				throw new ArgumentException($"Invalid RSA key algorithm: {algorithmName}");
			}

			var args = new RSAParameters
			{
				Exponent = reader.ReadBigInt().ToByteArray(unsigned: true),
				Modulus = reader.ReadBigInt().ToByteArray(unsigned: true),
			};

			Algorithm.ImportParameters(args);
			this.HasPrivateKey = false;
		}

		public Buffer GetPublicKeyBytes(string? algorithmName = null)
		{
			var args = Algorithm.ExportParameters(false);

			var writer = new SshDataWriter();
			writer.Write(algorithmName ?? KeyAlgorithmName, Encoding.ASCII);
			writer.Write(BigInt.UnsignedBigEndianFromByteArray(args.Exponent!));
			writer.Write(BigInt.UnsignedBigEndianFromByteArray(args.Modulus!));
			return writer.ToBuffer();
		}

		public void ImportParameters(RSAParameters parameters)
		{
			Algorithm.ImportParameters(parameters);
			HasPrivateKey = parameters.D?.Length > 0;
		}

		public RSAParameters ExportParameters(bool includePrivate)
		{
			return Algorithm.ExportParameters(includePrivate);
		}

		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				Algorithm.Dispose();
			}
		}
	}

	private class SignerVerifier : ISigner, IVerifier
	{
		private readonly KeyPair keyPair;
		private readonly HashAlgorithmName hashAlgorithmName;

		public SignerVerifier(KeyPair keyPair, HashAlgorithmName hashAlgorithmName)
		{
			this.keyPair = keyPair;
			this.hashAlgorithmName = hashAlgorithmName;
		}

		public int DigestLength => this.keyPair.Algorithm.KeySize / 8;

		public void Sign(Buffer data, Buffer signature)
		{
			if (signature.Count != DigestLength)
			{
				throw new ArgumentException("Invalid signature buffer size.");
			}

#if SSH_ENABLE_SPAN
			if (!this.keyPair.Algorithm.TrySignData(
				data.Span, signature.Span, this.hashAlgorithmName, RSASignaturePadding.Pkcs1, out _))
			{
				throw new InvalidOperationException("Failed to sign data.");
			}
#else
			Buffer result = this.keyPair.Algorithm.SignData(
				data.Array,
				data.Offset,
				data.Count,
				this.hashAlgorithmName,
				RSASignaturePadding.Pkcs1);
#if DEBUG
			Buffer.TrackAllocation(result.Count);
#endif
			result.CopyTo(signature);
#endif
		}

		public bool Verify(Buffer data, Buffer signature)
		{
			if (signature.Count != DigestLength)
			{
				throw new ArgumentException("Invalid signature size.");
			}

#if SSH_ENABLE_SPAN
			return this.keyPair.Algorithm.VerifyData(
				data.Span, signature.Span, this.hashAlgorithmName, RSASignaturePadding.Pkcs1);
#else
			return this.keyPair.Algorithm.VerifyData(
				data.ToArray(),
				signature.ToArray(),
				this.hashAlgorithmName,
				RSASignaturePadding.Pkcs1);
#endif
		}

		public void Dispose()
		{
			// Do not dispose the key pair - this class does not own it.
		}
	}
}
